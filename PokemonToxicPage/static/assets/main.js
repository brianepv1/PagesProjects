import { a as kt, d as Re, e as He, f as De, g as G, h as Be, i as Ne } from "./chunks/chunk-KEGBXSBN.esm.js"; import { a as k, b as Ie, c as Me, d as ke, e as Pe } from "./chunks/chunk-WT2TBPUY.esm.js"; import { a as fe } from "./chunks/chunk-I2WNT6E5.esm.js"; import { a as Pt, b as ut } from "./chunks/chunk-JPTXTYG6.esm.js"; import { a as j, b as Mt, c as A, d as Te, e as ct, f as B, h as xe, i as we, j as dt, k as x, l as Se, m as Le, n as mt, o as f, p as I, q as _e, r as Ce, s as Ae, t as w } from "./chunks/chunk-LYYSCYVV.esm.js"; import { a as be, b as E, c as It, e as rt, f as ot, g as ye, h as ve, i as Ee, j as at, k as lt, l as ht } from "./chunks/chunk-NDGZEH7P.esm.js"; import { a as ge } from "./chunks/chunk-YKBISVAA.esm.js"; import { a as v } from "./chunks/chunk-QBZUDWVQ.esm.js"; import { a as nt } from "./chunks/chunk-X5XVMBBB.esm.js"; import "./chunks/chunk-WJK2SHEX.esm.js"; var Rt = class { constructor(t) { this.el = t, this.scrollEl = this.el.querySelector(".TemplateCardCarousel__cards"), this.cards = Array.from(this.el.querySelectorAll(".TemplateCardCarousel__card")), this.buttons = Array.from(this.el.querySelectorAll(".TemplateCardCarousel__carouselBar")), this.init() } init() { this.buttons.forEach((t, e) => { t.addEventListener("click", () => { this.scrollTo(e) }) }), this.scrollEl.addEventListener("scroll", () => this.onScroll()), this.onScroll() } scrollTo(t) { let e = this.cards[t], s = (this.scrollEl.offsetWidth - e.offsetWidth) / 2, i = e.offsetLeft - s; this.scrollEl.scroll({ left: i, behavior: "smooth" }) } onScroll() { if (!this.scrollEl || this.cards.length === 0) return; let t = this.scrollEl.scrollLeft, e = window.getComputedStyle(this.scrollEl).columnGap, s = window.parseInt(e.slice(0, e.length - 2)), n = this.cards[0].offsetWidth, o = n + s, a = 0; for (let l = this.cards.length - 1; l >= 0; l--) { let c = l * o - .5 * n; if (t > c) { a = l; break } } this.scrollEl.scrollLeft >= this.scrollEl.scrollWidth - this.scrollEl.offsetWidth && (a = this.cards.length - 1), this.setActiveCard(a) } setActiveCard(t) { this.buttons.forEach((e, s) => { e.classList.toggle("active", t === s) }) } }; var Ht = class { constructor(t) { this.index = 0; this.animating = !1; if (this.el = t, this.slideEls = Array.from(this.el.querySelectorAll(".slide")), this.slideEls.length < 3) { console.warn("carousel should have at least 3 slides"); return } this.init() } init() { let t = this.el.querySelector(".prev"); t && t.addEventListener("click", () => this.prev()); let e = this.el.querySelector(".next"); e && e.addEventListener("click", () => this.prev()), this.updateState() } prev() { this.animating || (this.index -= 1, this.index < 0 && (this.index += this.slideEls.length), this.updateState()) } next() { this.animating || (this.index += 1, this.index >= this.slideEls.length && (this.index = 0), this.updateState()) } updateState() { this.animating = !0, this.activeEl && this.activeEl.classList.add("after"); let t = this.slideEls[this.index]; t && t.classList.add("active"), window.setTimeout(() => { let e = (this.index + 1) % this.slideEls.length, s = this.index - 1; s < 0 && (s += this.slideEls.length), this.slideEls.forEach((i, n) => { let o = n === this.index; i.setAttribute("aria-hidden", o ? "false" : "true") }), this.beforeEl && this.beforeEl.classList.remove("before"), this.beforeEl = this.slideEls[e], this.beforeEl.classList.add("before"), this.beforeEl.classList.remove("after"), this.beforeEl.classList.remove("active"), this.activeEl && this.activeEl.classList.remove("active"), this.activeEl = t, this.activeEl.classList.remove("before"), this.activeEl.classList.remove("after"), this.activeEl.classList.add("active"), this.afterEl && this.afterEl.classList.remove("after"), this.afterEl = this.slideEls[s], this.afterEl.classList.add("after"), this.afterEl.classList.remove("before"), this.afterEl.classList.remove("active"), this.animating = !1 }, 180) } }; var Dt = class { constructor(t) { this.el = t, this.initDates() } initDates() { let t = this.el.querySelectorAll(".upcomingevents__content__date"), e = (document.documentElement.lang || "en").replace("_", "-"); for (let s of Array.from(t)) { let i = s.getAttribute("data-date"), n = this.parseDate(i), o = s.querySelector(".upcomingevents__content__date__month"); o && (o.textContent = n.toLocaleDateString(e, { month: "short" })); let a = s.querySelector(".upcomingevents__content__date__day"); a && (a.textContent = n.toLocaleDateString(e, { day: "numeric" })) } } parseDate(t) { let e = t.split("-"); return new Date(+e[0], +e[1] - 1, +e[2]) } }; var Bt = class { constructor(t) { this.imageSources = t, this.images = {}, this.maxRetries = 3, this.decodeAfterFetch = !1, this.onEachImageLoaded = null } setLoadCallback(t) { this.onEachImageLoaded = t } getImages() { return this.images } setDecodeAfterFetch(t) { this.decodeAfterFetch = ve() ? !1 : t } load() { return new Promise(t => { let e = this.imageSources.map(s => this.fetchImage(s)); Promise.all(e).then(() => { t(this.images) }) }) } ping() { return new Promise(t => { let e = this.imageSources.map(s => this.pingSource(s)); Promise.all(e).then(() => { t(this.imageSources) }) }) } pingSource(t, e = 0) { return new Promise((s, i) => { fetch(t).then(n => { n.ok ? s(t) : (e++, e >= this.maxRetries ? i(`failed after ${e} tries`) : s(this.pingSource(t, e))) }) }) } fetchImage(t, e = 0) { return new Promise(s => { fetch(t).then(i => (i.ok || (e++, e >= this.maxRetries ? s() : this.fetchImage(t, e)), i.blob())).then(i => { let n = i, o = document.createElement("img"); this.decodeAfterFetch && "decode" in o ? (o.src = URL.createObjectURL(n), o.decoding = "async", o.decode().then(() => { this.images[t] = o, this.onEachImageLoaded && this.onEachImageLoaded(t, o), s() }).catch(() => { o.onload = () => { this.images[t] = o, this.onEachImageLoaded && this.onEachImageLoaded(t, o), s() }, o.src = URL.createObjectURL(n) })) : (o.onload = () => { this.images[t] = o, this.onEachImageLoaded && this.onEachImageLoaded(t, o), s() }, o.src = URL.createObjectURL(n)) }) }) } loadImageBitmaps() { return new Promise(t => { let e = this.imageSources.map(s => this.fetchImageBitmap(s)); Promise.all(e).then(() => { t(this.images) }) }) } fetchImageBitmap(t, e = 0) { return new Promise(s => { fetch(t).then(i => (i.ok || (e++, e >= this.maxRetries ? s() : this.fetchImageBitmap(t, e)), i.blob())).then(i => createImageBitmap(i)).then(i => { let n = i; this.images[t] = n, this.onEachImageLoaded && this.onEachImageLoaded(t, n), s() }) }) } loadBitmapOrImage() { return Ee() ? this.loadImageBitmaps() : this.load() } dispose() { for (let t in this.images) { if (!this.images[t]) return; let e = this.images[t]; e instanceof ImageBitmap ? e.close() : typeof e == "string" ? URL.revokeObjectURL(e) : e instanceof HTMLImageElement && G(e) } this.images = {} } }; var Nt = class { constructor(t) { this.loadedImages = {}; this.currentIndex = 0; this.currentImage = ""; this.isLoading = !1; this.el = t, this.mainImage = this.el.querySelector(".TemplateGallery__gallery__main__image img"), this.thumbnails = Array.from(this.el.querySelectorAll(".TemplateGallery__gallery__thumb")), this.init() } init() { !this.mainImage || (this.currentImage = this.thumbnails[0].getAttribute("data-image-url"), this.thumbnails.forEach((t, e) => { t.addEventListener("click", s => { s.preventDefault(), this.setIndex(e) }) }), window.addEventListener("resize", () => this.onResize())) } onResize() { this.loadedImages = {} } setIndex(t) { if (t === this.currentIndex || this.isLoading) return; let s = this.thumbnails[t].getAttribute("data-image-url"); this.loadImage(s), this.currentIndex = t } async loadImage(t) { if (this.isLoading) return; let e = Math.ceil(this.mainImage.offsetWidth * (window.devicePixelRatio || 1)), s = `${t}=w${e}`; if (!this.loadedImages[t]) { this.isLoading = !0, this.el.classList.add("image-loading"); let i = new Bt([s]); i.setDecodeAfterFetch(!0), await i.load() } window.requestAnimationFrame(() => { this.mainImage.src = s, this.isLoading = !1, this.el.classList.remove("image-loading") }) } prev() { let t = this.currentIndex - 1; t < 0 && (t += this.thumbnails.length), this.setIndex(t) } next() { let t = this.currentIndex + 1; t >= this.thumbnails.length && (t -= this.thumbnails.length), this.setIndex(t) } }; var Ot = class { constructor(t) { this.el = t, this.fetchPosts() } async fetchPosts() { let t = await window.fetch("/post/api/blog.list", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ locale: document.documentElement.lang || "en" }) }); if (!t.ok) return; let s = (await t.json()).data.blogPosts; this.renderPosts(s) } renderPosts(t) { let e = this.el.querySelector(".latestnews__posts"); t.forEach(s => { let i = this.createPost(s); e.appendChild(i) }), this.el.classList.add("ready") } createPost(t) { let e = this.createDom("img", { src: t.fields.meta.image?.url, width: t.fields.meta.image?.width, height: t.fields.meta.image?.height, alt: t.fields.meta.image?.alt || "" }), s = this.createDom("div", { class: "latestnews__post__image" }, e), i = new Date(t.status.publishedAtTimestamp), n = (document.documentElement.lang || "en").replace("_", "-"), o = i.toLocaleDateString([n, "en"], { month: "short", day: "numeric", year: "numeric" }), a = this.createDom("div", { class: "latestnews__post__content__date", text: o }), l = t.fields.meta.title, c = this.createDom("div", { class: "latestnews__post__content__title" }); l.indexOf("<i>") !== -1 ? c.innerHTML = l : (c.textContent = l, c.setAttribute("data-component", "MultilineEllipsis")); let m = this.createDom("div", { class: "latestnews__post__content" }, a, c), h = t.url || `/post/${t.slug}?hl=${n}`; return this.createDom("a", { class: "latestnews__post", href: h, title: c.textContent || "" }, s, m) } createDom(t, e, ...s) { let i = document.createElement(t); if (e) for (let n in e) n === "text" ? i.textContent = String(e[n]) : i.setAttribute(n, String(e[n])); return s && s.length > 0 && s.forEach(n => i.appendChild(n)), i } }; var ts = "\u2026", es = ["ja", "ko", "th", "zh_hant"], zt = class { constructor(t, e) { this.domWatcher = new w; this.el = t; let s = this.el.getAttribute("data-component-options"); s && (e = JSON.parse(s)), this.maxLines = e?.maxLines || 2, this.wordBreak = e?.wordBreak || "break-word", this.originalText = (this.el.textContent || "").trim(), this.el.setAttribute("title", this.originalText), this.domWatcher.add({ id: "resize", element: window, on: "smartResize", callback: () => this.clampLines(), eventOptions: { passive: !0 } }), this.domWatcher.run("resize") } clampLines() { this.el.textContent = ""; let t = window.getComputedStyle(this.el).lineHeight, e = 0; t && t.endsWith("px") && (e = window.parseInt(t)), this.el.style.maxHeight = e * this.maxLines + "px"; let { words: s, delim: i } = this.splitWords(this.originalText), n = document.createElement("span"); this.el.appendChild(n); let o = 1; for (let a = 0; a < s.length; a++) { let l = s[a]; if (n.textContent += i + l, n.offsetHeight > e) { if (o >= this.maxLines) { if (n.style.display = "inline-block", n.style.maxWidth = "100%", n.style.whiteSpace = "nowrap", this.wordBreak === "break-word") { let u = s.slice(a + 1).join(i); n.textContent += i + u, n.style.overflow = "hidden", n.style.textOverflow = "ellipsis" } else { let u = this.splitWords(n.textContent).words, H = u.slice(0, u.length - 1).join(i); n.textContent = H + ts } break } let c = this.splitWords(n.textContent).words, m = c.slice(0, c.length - 1).join(i); n.textContent = m; let h = document.createElement("span"); h.textContent = l, this.el.appendChild(document.createTextNode(" ")), this.el.appendChild(h), n = h, o += 1 } } } splitWords(t) { if (!this.isApacLocale()) return { words: t.split(" "), delim: " " }; let e = [], s = 0, i = 1; for (; i < t.length;) { if (t[i].match(/[\wé]/)) { i += 1; continue } let a = t.slice(s, i); e.push(a), s = i, i += 1 } let n = t.slice(s, i); return e.push(n), { words: e, delim: "" } } getLocale() { return document.documentElement.lang.toLowerCase() } isApacLocale() { return es.includes(this.getLocale()) } dispose() { this.domWatcher.dispose(), this.el.textContent = this.originalText } }; var X = class { constructor() { this.host = "" } async fetch(t, e) { let s = { "Content-Type": "application/json" }, i = `${this.host}/post/api/${t}`, n = await window.fetch(i, { method: "POST", headers: s, body: JSON.stringify(e) }); if (n.status !== 200) throw console.error(`${t} failed: `, n), new Error(await n.json()); return n.json() } }; var ss = new WeakMap; var N = r => typeof r == "function" && ss.has(r); var Ft = typeof window != "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0; var Y = (r, t, e = null) => { for (; t !== e;) { let s = t.nextSibling; r.removeChild(t), t = s } }; var g = {}, pt = {}; var S = `{{lit-${String(Math.random()).slice(2)}}}`, Wt = `<!--${S}-->`, Oe = new RegExp(`${S}|${Wt}`), W = "$lit$", ft = class { constructor(t, e) { this.parts = [], this.element = e; let s = [], i = [], n = document.createTreeWalker(e.content, 133, null, !1), o = 0, a = -1, l = 0, { strings: c, values: { length: m } } = t; for (; l < m;) { let h = n.nextNode(); if (h === null) { n.currentNode = i.pop(); continue } if (a++, h.nodeType === 1) { if (h.hasAttributes()) { let u = h.attributes, { length: H } = u, T = 0; for (let y = 0; y < H; y++)ze(u[y].name, W) && T++; for (; T-- > 0;) { let y = c[l], z = gt.exec(y)[2], F = z.toLowerCase() + W, D = h.getAttribute(F); h.removeAttribute(F); let C = D.split(Oe); this.parts.push({ type: "attribute", index: a, name: z, strings: C }), l += C.length - 1 } } h.tagName === "TEMPLATE" && (i.push(h), n.currentNode = h.content) } else if (h.nodeType === 3) { let u = h.data; if (u.indexOf(S) >= 0) { let H = h.parentNode, T = u.split(Oe), y = T.length - 1; for (let z = 0; z < y; z++) { let F, D = T[z]; if (D === "") F = L(); else { let C = gt.exec(D); C !== null && ze(C[2], W) && (D = D.slice(0, C.index) + C[1] + C[2].slice(0, -W.length) + C[3]), F = document.createTextNode(D) } H.insertBefore(F, h), this.parts.push({ type: "node", index: ++a }) } T[y] === "" ? (H.insertBefore(L(), h), s.push(h)) : h.data = T[y], l += y } } else if (h.nodeType === 8) if (h.data === S) { let u = h.parentNode; (h.previousSibling === null || a === o) && (a++, u.insertBefore(L(), h)), o = a, this.parts.push({ type: "node", index: a }), h.nextSibling === null ? h.data = "" : (s.push(h), a--), l++ } else { let u = -1; for (; (u = h.data.indexOf(S, u + 1)) !== -1;)this.parts.push({ type: "node", index: -1 }), l++ } } for (let h of s) h.parentNode.removeChild(h) } }, ze = (r, t) => { let e = r.length - t.length; return e >= 0 && r.slice(e) === t }, qt = r => r.index !== -1, L = () => document.createComment(""), gt = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/; var Z = class { constructor(t, e, s) { this.__parts = [], this.template = t, this.processor = e, this.options = s } update(t) { let e = 0; for (let s of this.__parts) s !== void 0 && s.setValue(t[e]), e++; for (let s of this.__parts) s !== void 0 && s.commit() } _clone() { let t = Ft ? this.template.element.content.cloneNode(!0) : document.importNode(this.template.element.content, !0), e = [], s = this.template.parts, i = document.createTreeWalker(t, 133, null, !1), n = 0, o = 0, a, l = i.nextNode(); for (; n < s.length;) { if (a = s[n], !qt(a)) { this.__parts.push(void 0), n++; continue } for (; o < a.index;)o++, l.nodeName === "TEMPLATE" && (e.push(l), i.currentNode = l.content), (l = i.nextNode()) === null && (i.currentNode = e.pop(), l = i.nextNode()); if (a.type === "node") { let c = this.processor.handleTextExpression(this.options); c.insertAfterNode(l.previousSibling), this.__parts.push(c) } else this.__parts.push(...this.processor.handleAttributeExpressions(l, a.name, a.strings, this.options)); n++ } return Ft && (document.adoptNode(t), customElements.upgrade(t)), t } }; var Fe = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: r => r }), ns = ` ${S} `, q = class { constructor(t, e, s, i) { this.strings = t, this.values = e, this.type = s, this.processor = i } getHTML() { let t = this.strings.length - 1, e = "", s = !1; for (let i = 0; i < t; i++) { let n = this.strings[i], o = n.lastIndexOf("<!--"); s = (o > -1 || s) && n.indexOf("-->", o + 1) === -1; let a = gt.exec(n); a === null ? e += n + (s ? ns : Wt) : e += n.substr(0, a.index) + a[1] + a[2] + W + a[3] + S } return e += this.strings[t], e } getTemplateElement() { let t = document.createElement("template"), e = this.getHTML(); return Fe !== void 0 && (e = Fe.createHTML(e)), t.innerHTML = e, t } }; var bt = r => r === null || !(typeof r == "object" || typeof r == "function"), yt = r => Array.isArray(r) || !!(r && r[Symbol.iterator]), K = class { constructor(t, e, s) { this.dirty = !0, this.element = t, this.name = e, this.strings = s, this.parts = []; for (let i = 0; i < s.length - 1; i++)this.parts[i] = this._createPart() } _createPart() { return new vt(this) } _getValue() { let t = this.strings, e = t.length - 1, s = this.parts; if (e === 1 && t[0] === "" && t[1] === "") { let n = s[0].value; if (typeof n == "symbol") return String(n); if (typeof n == "string" || !yt(n)) return n } let i = ""; for (let n = 0; n < e; n++) { i += t[n]; let o = s[n]; if (o !== void 0) { let a = o.value; if (bt(a) || !yt(a)) i += typeof a == "string" ? a : String(a); else for (let l of a) i += typeof l == "string" ? l : String(l) } } return i += t[e], i } commit() { this.dirty && (this.dirty = !1, this.element.setAttribute(this.name, this._getValue())) } }, vt = class { constructor(t) { this.value = void 0, this.committer = t } setValue(t) { t !== g && (!bt(t) || t !== this.value) && (this.value = t, N(t) || (this.committer.dirty = !0)) } commit() { for (; N(this.value);) { let t = this.value; this.value = g, t(this) } this.value !== g && this.committer.commit() } }, P = class { constructor(t) { this.value = void 0, this.__pendingValue = void 0, this.options = t } appendInto(t) { this.startNode = t.appendChild(L()), this.endNode = t.appendChild(L()) } insertAfterNode(t) { this.startNode = t, this.endNode = t.nextSibling } appendIntoPart(t) { t.__insert(this.startNode = L()), t.__insert(this.endNode = L()) } insertAfterPart(t) { t.__insert(this.startNode = L()), this.endNode = t.endNode, t.endNode = this.startNode } setValue(t) { this.__pendingValue = t } commit() { if (this.startNode.parentNode === null) return; for (; N(this.__pendingValue);) { let e = this.__pendingValue; this.__pendingValue = g, e(this) } let t = this.__pendingValue; t !== g && (bt(t) ? t !== this.value && this.__commitText(t) : t instanceof q ? this.__commitTemplateResult(t) : t instanceof Node ? this.__commitNode(t) : yt(t) ? this.__commitIterable(t) : t === pt ? (this.value = pt, this.clear()) : this.__commitText(t)) } __insert(t) { this.endNode.parentNode.insertBefore(t, this.endNode) } __commitNode(t) { this.value !== t && (this.clear(), this.__insert(t), this.value = t) } __commitText(t) { let e = this.startNode.nextSibling; t = t ?? ""; let s = typeof t == "string" ? t : String(t); e === this.endNode.previousSibling && e.nodeType === 3 ? e.data = s : this.__commitNode(document.createTextNode(s)), this.value = t } __commitTemplateResult(t) { let e = this.options.templateFactory(t); if (this.value instanceof Z && this.value.template === e) this.value.update(t.values); else { let s = new Z(e, t.processor, this.options), i = s._clone(); s.update(t.values), this.__commitNode(i), this.value = s } } __commitIterable(t) { Array.isArray(this.value) || (this.value = [], this.clear()); let e = this.value, s = 0, i; for (let n of t) i = e[s], i === void 0 && (i = new P(this.options), e.push(i), s === 0 ? i.appendIntoPart(this) : i.insertAfterPart(e[s - 1])), i.setValue(n), i.commit(), s++; s < e.length && (e.length = s, this.clear(i && i.endNode)) } clear(t = this.startNode) { Y(this.startNode.parentNode, t.nextSibling, this.endNode) } }, Et = class { constructor(t, e, s) { if (this.value = void 0, this.__pendingValue = void 0, s.length !== 2 || s[0] !== "" || s[1] !== "") throw new Error("Boolean attributes can only contain a single expression"); this.element = t, this.name = e, this.strings = s } setValue(t) { this.__pendingValue = t } commit() { for (; N(this.__pendingValue);) { let e = this.__pendingValue; this.__pendingValue = g, e(this) } if (this.__pendingValue === g) return; let t = !!this.__pendingValue; this.value !== t && (t ? this.element.setAttribute(this.name, "") : this.element.removeAttribute(this.name), this.value = t), this.__pendingValue = g } }, Tt = class extends K { constructor(t, e, s) { super(t, e, s); this.single = s.length === 2 && s[0] === "" && s[1] === "" } _createPart() { return new $t(this) } _getValue() { return this.single ? this.parts[0].value : super._getValue() } commit() { this.dirty && (this.dirty = !1, this.element[this.name] = this._getValue()) } }, $t = class extends vt { }, We = !1; (() => { try { let r = { get capture() { return We = !0, !1 } }; window.addEventListener("test", r, r), window.removeEventListener("test", r, r) } catch (r) { } })(); var xt = class { constructor(t, e, s) { this.value = void 0, this.__pendingValue = void 0, this.element = t, this.eventName = e, this.eventContext = s, this.__boundHandleEvent = i => this.handleEvent(i) } setValue(t) { this.__pendingValue = t } commit() { for (; N(this.__pendingValue);) { let n = this.__pendingValue; this.__pendingValue = g, n(this) } if (this.__pendingValue === g) return; let t = this.__pendingValue, e = this.value, s = t == null || e != null && (t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive), i = t != null && (e == null || s); s && this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options), i && (this.__options = rs(t), this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options)), this.value = t, this.__pendingValue = g } handleEvent(t) { typeof this.value == "function" ? this.value.call(this.eventContext || this.element, t) : this.value.handleEvent(t) } }, rs = r => r && (We ? { capture: r.capture, passive: r.passive, once: r.once } : r.capture); var Vt = class { handleAttributeExpressions(t, e, s, i) { let n = e[0]; return n === "." ? new Tt(t, e.slice(1), s).parts : n === "@" ? [new xt(t, e.slice(1), i.eventContext)] : n === "?" ? [new Et(t, e.slice(1), s)] : new K(t, e, s).parts } handleTextExpression(t) { return new P(t) } }, Ut = new Vt; function jt(r) { let t = Gt.get(r.type); t === void 0 && (t = { stringsArray: new WeakMap, keyString: new Map }, Gt.set(r.type, t)); let e = t.stringsArray.get(r.strings); if (e !== void 0) return e; let s = r.strings.join(S); return e = t.keyString.get(s), e === void 0 && (e = new ft(r, r.getTemplateElement()), t.keyString.set(s, e)), t.stringsArray.set(r.strings, e), e } var Gt = new Map; var Xt = new WeakMap, Q = (r, t, e) => { let s = Xt.get(t); s === void 0 && (Y(t, t.firstChild), Xt.set(t, s = new P(Object.assign({ templateFactory: jt }, e))), s.appendInto(t)), s.setValue(r), s.commit() }; typeof window != "undefined" && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.4.1"); var J = (r, ...t) => new q(r, t, "html", Ut); var Yt = class {
  constructor(t) { this.lastScrollY = window.scrollY; this.currentScrollY = window.scrollY; this.navmenuOpen = !1; this.localeToggleOpen = !1; this.rpc = new X; this.domWatcher = new w; this.onKey = t => { t.key === "Escape" && (this.toggleNavMenu(!1), this.toggleLocaleMenu(!1)) }; this.el = t, this.el.classList.toggle("top", this.currentScrollY === 0), this.raf = new v(() => { this.raf.read(() => { this.currentScrollY = window.scrollY }), this.raf.write(() => { this.el.classList.toggle("top", this.currentScrollY === 0); let s = this.currentScrollY - this.lastScrollY; Math.abs(s) < 20 || (this.el.classList.toggle("down", s > 0), this.el.classList.toggle("up", s < 0), this.lastScrollY = this.currentScrollY) }) }), this.raf.runWhen(() => document.visibilityState === "visible"), this.raf.setFps(30), this.raf.start(); let e = this.el.querySelectorAll(".navbar__navMenu button"); for (let s = 0; s < e.length; s++)e[s].addEventListener("click", () => this.toggleNavMenu()); this.locale = document.documentElement.lang.replace("-", "_"), this.localeToggle = this.el.querySelector(".navbar__localeToggle"), this.initLocaleToggle(), window.addEventListener("keydown", this.onKey), this.el.querySelector(".promoBanner") || this.fetchPromos(), this.domWatcher.add({ element: window, on: "smartResize", callback: Me(() => this.updateNavbarHeight(), 100) }), this.updateNavbarHeight() } initLocaleToggle() { let t = this.localeToggle.querySelector(".navbar__localeToggle__locales"); if (!!t?.children.length) { t.setAttribute("role", "listbox"); for (let e = 0; e < t.children.length; e++) { let s = t.children[e]; s.setAttribute("role", "option"), s.setAttribute("aria-selected", "false") } this.localeToggle.addEventListener("click", () => { this.toggleLocaleMenu() }) } } isPromoBannerEnabled() { let t = document.querySelector(".LayoutModules"); return !(t && (t.getAttribute("data-page") || "").startsWith("gofest-2022")) } toggleLocaleMenu(t) { if (typeof t == "undefined" && (t = !this.localeToggleOpen), this.localeToggleOpen = t, this.el.classList.toggle("navbar--localeToggleOpen", this.localeToggleOpen), t) { let e = this.localeToggle.querySelector(".navbar__localeToggle__locales"); if (e) { let s = Be(e); s.length > 0 && s[0].focus() } window.setTimeout(() => { document.body.addEventListener("click", () => this.toggleLocaleMenu(!1), { once: !0 }) }) } } toggleNavMenu(t) { typeof t == "undefined" && (t = !this.navmenuOpen), this.navmenuOpen = t, this.el.classList.toggle("navbar--navMenuOpen", this.navmenuOpen), document.body.classList.toggle("navMenuOpen", this.navmenuOpen) } async fetchPromos() { let t = await this.rpc.fetch("promos.get", { locale: this.locale }); if (!t.data?.promo) return; let e = t.data.promo; if (this.isUrlOfCurrentPage(e.button_url) || sessionStorage.getItem(this.getDismissPromoStorageId(e.id)) === "true") return; let s = document.createElement("div"); s.className = "navbar__promoBanner", this.el.appendChild(s); let i = this.renderPromo(e); Q(i, s), document.body.classList.add("promoBannerVisible"); let n = s.firstElementChild; e.style?.background_color && kt(n, "--backgroundColor", e.style.background_color), e.style?.text_color && kt(n, "--textColor", e.style.text_color), this.updateNavbarHeight() } renderPromo(t) {
    let e = { handleEvent: () => this.dismissPromo(t) }, s = []; t.image && s.push(J`
        <div class="promoBanner__image">
          <img src="${t.image.url}" alt="${t.image.alt_text}" width="${t.image.width}" height="${t.image.height}" />
        </div>
      `); let i = t.analytics?.category || "PromoBanner", n = t.analytics?.action || "Click", o = t.analytics?.label || t.button_url, a = t.button_url; if (this.isRelativeUrl(a)) if (!a.includes("?")) a = `${a}?hl=${this.locale}`; else { let l = new URL(a, window.location.href); l.searchParams.set("hl", this.locale), a = l.toString() } return J`
      <div class="promoBanner">
        ${s}
        <div class="promoBanner__body">${t.body}</div>
        <div class="promoBanner__button">
          <a class="button" role="button" href="${a}" aria-label="${t.button_label}: ${t.body}">
            <span class="button__label">${t.button_label}</span>
          </a>
        </div>
        <button class="promoBanner__x" aria-label="Close" @click=${e} data-ga-on="click" data-ga-event-category="${i}" data-ga-event-action="${n}" data-ga-event-label="${o}">✕</button>
      </div>
    `} isRelativeUrl(t) { return t.startsWith("/") || t.startsWith("https://pokemongolive.com/") } dismissPromo(t) { sessionStorage.setItem(this.getDismissPromoStorageId(t.id), "true"), this.el.classList.add("dismissPromo"), document.body.classList.remove("promoBannerVisible"), this.updateNavbarHeight() } getDismissPromoStorageId(t) { return `promo::${t}::dismissed` } isUrlOfCurrentPage(t) { if (!t) return !1; let e = new URL(t, location.href); return e.host && e.host !== window.location.host ? !1 : window.location.pathname === e.pathname || window.location.pathname === `/${this.locale}${e.pathname}` } updateNavbarHeight() { let t = Math.floor(this.el.getBoundingClientRect().height); document.body.style.setProperty("--navbar-height", `${t}px`) } dispose() { this.raf.stop(), this.raf.dispose(), this.el.classList.remove("top"), this.el.classList.remove("up"), this.el.classList.remove("down"), window.removeEventListener("keydown", this.onKey) }
}; function Zt(r, ...t) { let e = null, s = Number.NEGATIVE_INFINITY, i = t[0]; return r.forEach(n => { let o = i(n); if (s < o) e = n, s = o; else if (s === o && t.length > 1) { let a = 1, l = t[a]; for (; a < t.length && l(e) === l(n);)l = t[a++]; l(e) < l(n) && (e = n) } }), e } function wt(r, ...t) { return Zt(r, ...t.map(e => s => -1 * e(s))) } function qe(r, t, e, s = 1) { let i = [], n = r.length, o = Math.sign(s), a = I(e, 0, n), l = I(t, 0, n); for (; l !== a;)i.push(r[l]), l = I(l + o, 0, n); return i } function $e(...r) { let t = new Set; return r.forEach(e => { e.forEach(s => { t.add(s) }) }), t } var d = class { constructor(t = 0, e = 0, s = 0, i = 0) { this.x = t || 0, this.y = e || 0, this.z = s || 0, this.w = i || 0 } clone() { return new d(this.x, this.y, this.z) } static clone(t) { return new d(t.x, t.y, t.z) } set(t, e, s = 0) { return this.x = t, this.y = e, this.z = s, this } floor() { return this.x = ~~this.x, this.y = ~~this.y, this.z = ~~this.z, this } int() { return this.x = this.x >> 0, this.y = this.y >> 0, this.z = this.z >> 0, this } equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z } static equals(t, e) { return t.x === e.x && t.y === e.y && t.z === e.z } toArray() { return [this.x, this.y, this.z] } static toArray(t) { return [t.x, t.y, t.z] } static fromArray(t) { return new d(t[0], t[1], t[2]) } static create(t, e, s = 0) { return new d(t, e, s) } static fromAngle(t, e = 1e5) { return new d(e * Math.cos(t), e * Math.sin(t), 0) } static angle2d(t, e) { let s = t.x - e.x, i = t.y - e.y; return Math.atan2(i, s) } static getXyzRotationTo(t, e) { let s = t.clone().subtract(e), i = Math.atan(s.x), n = Math.atan(s.y), o = Math.atan(s.z); return [i, n, o] } static getEularRotationTo(t, e) { let s = t.clone().normalize().subtract(e.clone().normalize()), i = -Math.atan(s.x), n = Math.atan(s.y), o = -Math.atan(s.z); return new d(B(i), B(n), B(o)) } add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this } static add(t, e) { let s = t.x + e.x, i = t.y + e.y, n = t.z + e.z; return new d(s, i, n) } subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this } static subtract(t, e) { let s = t.x - e.x, i = t.y - e.y, n = t.z - e.z; return new d(s, i, n) } multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this } divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this } scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t, this) : d.ZERO } negate() { return this.x = -this.x, this.y = -this.y, this.z = Mt(-this.z), this } static negate(t) { let e = -t.x, s = -t.y, i = Mt(-t.z); return new d(e, s, i) } distance(t) { let e = t.x - this.x, s = t.y - this.y, i = t.z - this.z || 0; return Math.sqrt(e * e + s * s + i * i) } length() { let t = this.x, e = this.y, s = this.z; return Math.sqrt(t * t + e * e + s * s) } lengthSquared() { return this.x * this.x + this.y * this.y + this.z * this.z } magnitude() { return this.length() } normalize() { let t = this.x, e = this.y, s = this.z, i = t * t + e * e + s * s; return i > 0 && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i, this.z = s * i), this } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } cross(t) { let e = this.x, s = this.y, i = this.z, n = t.x, o = t.y, a = t.z; return this.x = s * a - i * o, this.y = i * n - e * a, this.z = e * o - s * n, this } transformWithMatrixIV(t) { let e = this.x, s = this.y, i = this.z, n = t.value, o = e * n[0] + s * n[4] + i * n[8] + n[12], a = e * n[1] + s * n[5] + i * n[9] + n[13], l = e * n[2] + s * n[6] + i * n[10] + n[14], c = e * n[3] + s * n[7] + i * n[11] + n[15]; return c = c || 1, this.x = o / c, this.y = a / c, this.z = l / c, new d(this.x, this.y, this.z) } transformWithMatrixIVTo2d(t) { return this.transformWithMatrixIV(t).set(this.x, this.y, 0) } lerp(t, e = 0) { return this.x = x(this.x, t.x, e), this.y = x(this.y, t.y, e), this.z = x(this.z, t.z, e), this } damp(t, e = 0, s) { return this.x = mt(this.x, t.x, e, s), this.y = mt(this.y, t.y, e, s), this.z = mt(this.z, t.z, e, s), this } ease(t, e = 0, s = j) { return this.x = f(this.x, t.x, e, s), this.y = f(this.y, t.y, e, s), this.z = f(this.z, t.z, e, s), this } static ease(t, e, s = 0, i = j) { let n = f(t.x, e.x, s, i), o = f(t.y, e.y, s, i), a = f(t.z, e.z, s, i); return new d(n, o, a) } static min(t, e) { return new d(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.min(t.z, e.z)) } static max(t, e) { return new d(Math.max(t.x, e.x), Math.max(t.y, e.y), Math.max(t.z, e.z)) } static degreeToRadians(t) { return new d(ct(t.x), ct(t.y), ct(t.z)) } degreeToRadians() { return d.degreeToRadians(this) } static clamp(t, e, s) { return new d(A(t.x, e.x, s.x), A(t.y, e.y, s.y), A(t.z, e.z, s.z)) } static fromRotationMatrixIV(t) { let e = d.ZERO, s = t.value, i = s[0], n = s[4], o = s[8], a = s[1], l = s[5], c = s[9], m = s[2], h = s[6], u = s[10]; return e.y = Math.asin(A(-1, 1, o)), Math.abs(o) < .9999999 ? (e.x = Math.atan2(-c, u), e.z = Math.atan2(-n, i)) : (e.x = Math.atan2(h, l), e.z = 0), e.x = B(e.x), e.y = B(e.y), e.z = B(e.z), e } static get ZERO() { return new d(0, 0, 0) } static get ONE() { return new d(1, 1, 1) } static get RIGHT() { return new d(1, 0, 0) } static get LEFT() { return new d(-1, 0, 0) } static get UP() { return new d(0, -1, 0) } static get DOWN() { return new d(0, 1, 0) } static get FORWARD() { return new d(0, 0, 1) } static get BACK() { return new d(0, 0, -1) } }; var as = ["mousemove", "touchstart", "touchmove"], $; (function (r) { r.UPDATE = "update" })($ || ($ = {})); var p = class { constructor() { p.uses.size === 0 && (p.raf = new v(() => p.loop()), p.clientPosition = d.ZERO, p.nextClientPosition = d.ZERO, p.domWatcher = new w, p.eventManager = new ut, as.forEach(t => { p.domWatcher.add({ element: window, on: t, eventOptions: { passive: !0 }, callback: e => p.updatePosition(e) }) }), p.raf.start()), p.uses.add(this) } static updatePosition(t) { t instanceof MouseEvent ? this.updatePositionFromEvent(t) : t instanceof TouchEvent && this.updatePositionFromTouchEvent(t) } static updatePositionFromTouchEvent(t) { t.touches.length > 0 && this.updatePositionFromEvent(t.touches[0]) } static updatePositionFromEvent(t) { this.nextClientPosition = new d(t.clientX, t.clientY) } static loop() { this.raf.preRead(() => { var t; this.nextClientPosition && ((t = this.clientPosition) === null || t === void 0 ? void 0 : t.equals(this.nextClientPosition)) || (this.clientPosition = this.nextClientPosition, this.eventManager.dispatch($.UPDATE)) }) } on(t, e) { p.eventManager.on(t, e) } off(t, e) { p.eventManager.off(t, e) } getClientPosition() { return p.clientPosition } dispose() { p.uses.delete(this), p.uses.size === 0 && (p.domWatcher.dispose(), p.raf.dispose(), p.clientPosition = null, p.eventManager.dispose()) } }; p.uses = new Set; var R = class { constructor(t, e, s, i) { this.x2 = t, this.y2 = e, this.x3 = t, this.y3 = i } static getBezierPoint(t, e, s, i, n, o, a, l, c) { let m = 1 - t, h = t * t * t * l + 3 * t * t * m * o + 3 * t * m * m * i + m * m * m * e, u = t * t * t * c + 3 * t * t * m * a + 3 * t * m * m * n + m * m * m * s; return { x: h, y: u } } static getPoint(t, e, s, i, n) { return R.getBezierPoint(t, e.x, e.y, s.x, s.y, i.x, i.y, n.x, n.y) } static interpolateProgress(t, e, s, i, n) { return R.getBezierPoint(t, 0, 0, e, s, i, n, 1, 1).y } interpolate(t) { return R.interpolateProgress(t, this.x2, this.y2, this.x3, this.y3) } easingFunction() { return t => this.interpolate(t) } static makeEasingFunction(t, e, s, i) { return n => this.interpolateProgress(n, t, e, s, i) } static makeEasingFunctionFromString(t) { let e = t.split(","); return R.makeEasingFunction(+e[0], +e[1], +e[2], +e[3]) } }; var tt; (function (r) { r[r.LEFT = -1] = "LEFT", r[r.RIGHT = 1] = "RIGHT" })(tt || (tt = {})); var Ve = class { constructor(t, e, s) { this.target = t, this.timeRange = e, this.startDistance = s } }, Ue = class { constructor(t, e) { this.startX = t, this.startTime = e, this.lastMouseX = t } }; function je(r) { let t = Re(r).transform; return !t.length || t === "none" ? 0 : parseFloat(t.slice(7, -1).split(",")[4]) } var M = class { constructor({ transitionTime: t = 500, easingFunction: e = M.DEFAULT_EASING } = {}) { this.raf = new v(() => this.onRaf()), this.domWatcher = new w, this.easingFunction = e, this.transitionTime = t, this.transitionTarget = null, this.resizeTimeout = null, this.mouseTracker = new p, this.interaction = null, this.xTranslate = Pt.usingFunction(s => je(s)), this.lastXTranslate = Pt.usingFunction(() => null), this.startInteractionCallback = () => this.startInteractionOnMouseUpdate() } static sumWidth(t) { return Ae(t.map(e => e.offsetWidth)) } init(t) { this.initResizeHandler(), this.carousel = t, this.raf.read(() => this.transition(t.getFirstSlide(), 0)), this.initDraggableSlides(), this.raf.start() } onRaf() { this.carousel.isDisabled() || this.raf.read(() => { !this.isInteracting() && this.transitionTarget ? this.renderTransition() : (this.isInteracting() && this.renderInteraction(), this.loopSlides()), this.applyXTranslations() }) } transition(t, e = null) { if (this.transitionTarget !== null && this.transitionTarget.target === t) return; let s = e === null ? this.transitionTime : e, i = performance.now(), n = [i, i + s], o = this.getDistanceToCenter(t); this.transitionTarget = new Ve(t, n, o) } getActiveSlide() { return wt(this.carousel.getSlides(), t => Math.abs(this.getDistanceBetween(t, this.carousel.container)), t => -1 * this.carousel.getIndex(t)) } hasTransitionedTo(t) { return this.getDistanceToCenter(t) === 0 } isInteracting() { return this.interaction !== null } dispose() { this.resizeTimeout && window.clearTimeout(this.resizeTimeout), this.mouseTracker.dispose(), this.domWatcher.dispose(), this.xTranslate.clear(), this.lastXTranslate.clear() } initResizeHandler() { this.domWatcher.add({ element: window, on: "resize", eventOptions: { passive: !0 }, callback: () => { this.resizeTimeout && window.clearTimeout(this.resizeTimeout), this.resizeTimeout = window.setTimeout(() => this.transition(this.carousel.getActiveSlide(), 0)) } }) } constrainXTranslations() { if (this.carousel.loop) return; let t = this.carousel.getSlides(), e = this.carousel.container.offsetWidth / 2, s = M.sumWidth(t), n = t.slice(-1)[0].offsetWidth / 2, o = t[0].offsetWidth / 2, a = e - s + n, l = e - o; t.forEach(c => { let m = this.xTranslate.get(c); this.xTranslate.set(c, A(a, l, m)) }) } applyXTranslations() { this.constrainXTranslations(), this.raf.write(() => { this.xTranslate.forEach((t, e) => { this.lastXTranslate.get(e) !== t && (e.style.transform = `translateX(${t}px)`, this.lastXTranslate.set(e, t)) }) }) } renderInteraction() { let t = this.getMouseX(), e = t - this.interaction.lastMouseX; this.interaction.lastMouseX = t, this.carousel.getSlides().forEach(s => { this.translate(s, e) }) } getDistanceToCenter(t) { return this.getDistanceBetween(t, this.carousel.container) } initDraggableSlides() { this.carousel.getSlides().forEach(t => { ["touchstart", "mousedown"].forEach(e => { this.domWatcher.add({ element: t, on: e, eventOptions: { passive: !0 }, callback: () => this.startInteraction() }) }), ["contextmenu", "dragstart", "touchend", "mouseup"].forEach(e => { this.domWatcher.add({ element: window, on: e, eventOptions: { passive: !0 }, callback: () => this.endInteraction() }) }) }) } getEasedTransitionPercent() { let t = Se(this.transitionTarget.timeRange[0], this.transitionTarget.timeRange[1], performance.now()); return this.easingFunction(t) } renderTransition() { let t = this.transitionTarget; if (!t) return; let e = this.getEasedTransitionPercent(), s = x(t.startDistance, 0, e), i = this.getDistanceToCenter(t.target), n = Math.abs(s) - Math.abs(i), o = Math.sign(i), a = n * o; this.carousel.getSlides().forEach(l => this.translate(l, a)), this.loopSlides(), e === 1 && (this.transitionTarget = null) } translate(t, e) { let s = Math.round((this.xTranslate.get(t) + e) * 100) / 100; this.xTranslate.set(t, s) } loopSlides() { if (!this.carousel.loop) return; let t = this.transitionTarget && this.transitionTarget.target || this.carousel.getActiveSlide(), e = this.carousel.getIndex(t), s = this.carousel.getSlides(), i = new Set(s.filter(h => h !== t)), n = t.getBoundingClientRect().left, o = { area: Math.max(n, 0), index: e, direction: tt.LEFT }, a = Ne().clientWidth, l = n + t.offsetWidth, c = { area: Math.min(a, a - l), index: e, direction: tt.RIGHT }, m = [o, c]; for (; i.size > 0;) { let h = Zt(m, y => y.area); h.index += h.direction; let u = s[I(h.index, 0, s.length)]; h.area -= u.offsetWidth; let T = this.getDesiredDistanceBetween(t, u, h.direction) - this.getDistanceBetween(u, t); T !== 0 && this.translate(u, T), i.delete(u) } } startInteraction() { var t; this.isInteracting() || (t = this.mouseTracker) === null || t === void 0 || t.on($.UPDATE, this.startInteractionCallback) } startInteractionOnMouseUpdate() { this.cancelStartInteractionCallback(), this.interaction = new Ue(this.getMouseX(), performance.now()), this.transitionTarget = null, this.carousel.stopTransition() } cancelStartInteractionCallback() { var t; (t = this.mouseTracker) === null || t === void 0 || t.off($.UPDATE, this.startInteractionCallback) } endInteraction() { if (this.interaction === null) { this.cancelStartInteractionCallback(); return } let t = performance.now() - this.interaction.startTime, e = this.getActiveSlide(), s = this.getDistanceToCenter(e), i = this.getMouseX() - this.interaction.startX, n = t > 700 ? i : 0; this.interaction = null; let o = Math.sign(n), a = Math.sign(s) * -1, l = this.carousel.loop; s === 0 || a === o || n === 0 ? this.carousel.goToSlide(e) : o === tt.RIGHT ? l || e !== this.carousel.getFirstSlide() ? this.carousel.prev() : this.carousel.goToSlide(e) : l || e !== this.carousel.getLastSlide() ? this.carousel.next() : this.carousel.goToSlide(e) } getMouseX() { return this.mouseTracker.getClientPosition().x } getCenter(t) { if (!t) return 0; let e = t.getBoundingClientRect(), s = e.left + e.width / 2, i = this.xTranslate.get(t) - je(t); return s + i } getDistanceBetween(t, e = null) { let s = this.getCenter(t); return e !== null ? s - this.getCenter(e) : s - document.children[0].clientWidth / 2 } getDesiredDistanceBetween(t, e, s) { if (t === e) return 0; let i = this.getInBetweenSlides(t, e, s), n = M.sumWidth(i), o = e.offsetWidth / 2, a = t.offsetWidth / 2; return (o + n + a) * s } getInBetweenSlides(t, e, s) { let i = this.carousel.getIndex(t), n = this.carousel.getIndex(e) - s; return i === n ? [] : this.carousel.loop ? qe(this.carousel.getSlides(), n, i, -s) : this.carousel.getSlides().slice(Math.min(i + 1, n), Math.max(i, n + s)) } }; M.DEFAULT_EASING = new R(.445, .05, .55, .95).easingFunction(); var St = class { init(t) { this.activeSlide = t.getFirstSlide() } getActiveSlide() { if (!this.activeSlide) throw new Error("CssClassesOnly transition not initialized"); return this.activeSlide } transition(t) { this.activeSlide = t } hasTransitionedTo(t) { return this.activeSlide === t } isInteracting() { return !1 } dispose() { } }; var ls = "data-index", V; (function (r) { r[r.LEFT = -1] = "LEFT", r[r.RIGHT = 1] = "RIGHT" })(V || (V = {})); var U; (function (r) { r.BEFORE_CHANGE = "beforeChange", r.AFTER_CHANGE = "afterChange" })(U || (U = {})); var et; (function (r) { r.ACTIVE_SLIDE = "active", r.BEFORE_SLIDE = "before", r.AFTER_SLIDE = "after" })(et || (et = {})); var Ge = class { constructor(t, e) { this.callback = t, this.delay = e, this.timePassed = 0, this.timeout = setTimeout(t, e), this.lastStartTime = +new Date } isPaused() { return this.timeout === null } pause() { this.isPaused() || (this.timePassed += +new Date - this.lastStartTime, this.clear()) } unpause() { !this.isPaused() || (this.timeout = setTimeout(this.callback, this.delay - this.timePassed), this.lastStartTime = +new Date) } dispose() { this.clear() } clear() { this.timeout && (clearTimeout(this.timeout), this.timeout = null) } }, Kt = class { constructor(t, e, { condition: s = () => !0, activeCssClass: i = et.ACTIVE_SLIDE, beforeCssClass: n = et.BEFORE_SLIDE, afterCssClass: o = et.AFTER_SLIDE, distanceToActiveSlideAttr: a = ls, loop: l = !0, transition: c = void 0, autoplaySpeed: m = void 0 } = {}) { if (e.length < 1) throw new Error("Cannot start carousel without slides"); if (this.raf = new v(() => this.onRaf()), this.activeCssClass = i, this.beforeCssClass = n, this.afterCssClass = o, this.distanceToActiveSlideAttr = a, this.loop = l, this.condition = s, this.container = t, this.lastActiveSlide = null, this.eventManager = new ut, this.slides = e, typeof c == "string") switch (c) { case "css": this.transition = new St; break; case "draggable": this.transition = new M; break; default: throw new Error(`Unrecognized transition type "${c}" passed to Carousel.`) } else this.transition = c || new St; this.transitionTarget = null, this.autoplaySpeed = m, this.autoplayTimeout = null, this.syncedCarousels = new Set([this]), this.init() } isDisabled() { return !this.condition() } isEnabled() { return this.condition() } goTo(t, e = !1) { typeof t == "number" ? this.goToIndex(t, e) : this.goToSlide(t, e) } goToSlide(t, e = !1) { this.isBeingInteractedWith() || this.transitionTarget !== t && (this.transitionTarget = t, this.eventManager.dispatch(U.BEFORE_CHANGE, { carousel: this, currentSlide: this.getActiveSlide(), currentIndex: this.getActiveIndex(), nextSlide: this.transitionTarget, nextIndex: this.getIndex(this.transitionTarget) }), e || this.syncedCarousels.forEach(s => { s !== this && s.syncTo(this.getIndex(t), this) })) } isBeingInteractedWith() { return this.transition.isInteracting() } getActiveSlide() { return this.transition.getActiveSlide() } getActiveIndex() { return this.getIndex(this.getActiveSlide()) } getFirstSlide() { return this.slides[0] } getLastSlide() { return this.slides[this.slides.length - 1] } getIndex(t) { return this.getSlides().indexOf(t) } getSlides() { return [...this.slides] } getSlidesBefore(t) { return this.loop ? this.splitSlidesInHalf(t, V.LEFT) : this.getSlides().slice(0, this.getSlides().indexOf(t)) } getSlidesAfter(t) { return this.loop ? this.splitSlidesInHalf(t, V.RIGHT) : this.getSlides().slice(this.getSlides().indexOf(t) + 1) } next() { this.transitionSlidesBy(1) } prev() { this.transitionSlidesBy(-1) } goToIndex(t, e = !1) { let s = this.getClampedIndex(t); this.goToSlide(this.getSlideByIndex(s), e) } on(t, e) { this.eventManager.on(t, e) } off(t, e) { this.eventManager.off(t, e) } getSlideByIndex(t) { return this.slides[t] } getSlideCount() { return this.slides.length } dispose() { this.raf.dispose(), this.transition.dispose() } stopTransition() { this.transitionTarget = null } getClampedIndex(t) { let e = this.getSlides().length; return this.loop ? I(t, 0, e) : A(0, e - 1, t) } sync(...t) { let e = $e(this.syncedCarousels, ...t.map(s => s.syncedCarousels)); this.syncedCarousels = e, e.forEach(s => s.syncedCarousels = e) } pause() { this.autoplayTimeout && this.autoplayTimeout.pause() } unpause() { this.autoplayTimeout && this.autoplayTimeout.unpause() } isPaused() { return this.autoplayTimeout === null || this.autoplayTimeout.isPaused() } transitionSlidesBy(t) { let e = this.getSlides().indexOf(this.transitionTarget || this.getActiveSlide()) + t; this.goToIndex(e) } syncTo(t, e) { let s = t % this.getSlideCount(); if (this.getIndex(this.transitionTarget) % e.getSlideCount() !== s) if (this.getSlideCount() > e.getSlideCount()) { let n = [], o = s; for (; o < this.getSlideCount();)n.push(o), o += e.getSlideCount(); this.goTo(wt(n, a => Math.abs(this.getActiveIndex() - a)), !0) } else this.goTo(s, !0) } getHalfOfSlideCount(t) { let e = (this.getSlides().length - 1) / 2; return e % 2 == 0 ? e : t ? Math.ceil(e) : Math.floor(e) } splitSlidesInHalf(t, e) { let s = this.getHalfOfSlideCount(e === V.RIGHT), i = [], n = this.getIndex(t); for (; i.length < s;) { n = I(n + e, 0, this.getSlideCount()); let o = this.getSlideByIndex(n); e === V.RIGHT ? i.push(o) : i.unshift(o) } return i } init() { this.transition.init(this), this.raf.start(), this.resetAutoplayTimeout() } resetAutoplayTimeout() { this.autoplaySpeed && (this.autoplayTimeout && this.autoplayTimeout.dispose(), this.autoplayTimeout = new Ge(() => this.next(), this.autoplaySpeed)) } onRaf() { this.raf.read(() => { if (this.condition()) this.unpause(); else { this.pause(); return } this.isBeingInteractedWith() && this.resetAutoplayTimeout(); let t = this.getActiveSlide(); t !== this.lastActiveSlide && (this.lastActiveSlide = t, t && this.updateClasses(t)), this.transitionTarget !== null && (this.transition.hasTransitionedTo(this.transitionTarget) ? (this.transitionTarget = null, this.eventManager.dispatch(U.AFTER_CHANGE, { carousel: this, currentSlide: this.getActiveSlide(), currentIndex: this.getActiveIndex() }), this.resetAutoplayTimeout()) : this.transition.transition(this.transitionTarget)) }) } updateClasses(t) { let e = this.getSlidesBefore(t), s = this.getSlidesAfter(t); this.raf.write(() => { t.classList.add(this.activeCssClass), t.classList.remove(this.beforeCssClass, this.afterCssClass), t.setAttribute(this.distanceToActiveSlideAttr, "0"), e.reverse().forEach((i, n) => { i.classList.add(this.beforeCssClass), i.classList.remove(this.activeCssClass, this.afterCssClass), i.setAttribute(this.distanceToActiveSlideAttr, `${-n - 1}`) }), s.forEach((i, n) => { i.classList.add(this.afterCssClass), i.classList.remove(this.activeCssClass, this.beforeCssClass), i.setAttribute(this.distanceToActiveSlideAttr, `${n + 1}`) }) }) } }; var Qt = class { constructor(t) { this.prev = () => { this.carousel.prev() }; this.next = () => { this.carousel.next() }; this.el = t; let e = this.el.querySelector(".carouselRocket__leaders__carousel"), s = Array.from(this.el.querySelectorAll(".carouselRocket__leaders__carousel__slide")); this.carousel = new Kt(e, s, { loop: !1 }), this.numSlides = s.length, this.prevButton = this.el.querySelector(".carouselRocket__leaders__carouselButton--prev"), this.prevButton && this.prevButton.addEventListener("click", this.prev), this.nextButton = this.el.querySelector(".carouselRocket__leaders__carouselButton--next"), this.nextButton && this.nextButton.addEventListener("click", this.next), this.carousel.on(U.AFTER_CHANGE, i => { this.onChange(i.currentIndex), this.carousel.getSlides().forEach((n, o) => { n.setAttribute("aria-hidden", o === i.currentIndex ? "false" : "true") }) }), this.onChange(this.carousel.getActiveIndex()) } onChange(t) { this.prevButton && (this.prevButton.disabled = t === 0), this.nextButton && (this.nextButton.disabled = t === this.numSlides - 1) } dispose() { this.prevButton && this.prevButton.removeEventListener("click", this.prev), this.nextButton && this.nextButton.removeEventListener("click", this.next) } }; var Jt = class { constructor(t) { this.el = t, this.scroller = t.querySelector("[data-scrollx-scroller]"), this.scroller.addEventListener("scroll", () => this.onScroll()), this.onScroll(), window.setTimeout(() => this.onScroll(), 1e3); let e = this.el.querySelectorAll("[data-scrollx-left]"); for (let i = 0; i < e.length; i++)e[i].addEventListener("click", () => this.scrollLeft()); let s = this.el.querySelectorAll("[data-scrollx-right]"); for (let i = 0; i < s.length; i++)s[i].addEventListener("click", () => this.scrollRight()) } onScroll() { let t = this.scroller.scrollLeft, e = this.scroller.scrollWidth - this.scroller.clientWidth; this.el.classList.toggle("scroll-start", t === 0), this.el.classList.toggle("scroll-middle", t > 0 && t < e), this.el.classList.toggle("scroll-end", t === e) } scrollLeft() { this.scroller.scrollLeft -= 144 } scrollRight() { this.scroller.scrollLeft += 144 } }; var st = class { constructor(t) { this.scrolled = !1; this.el = t, this.raf = new v(() => this.rafLoop()); let e = this.getStickyParent(t); this.raf.start(), window.addEventListener("scroll", () => { this.scrolled = !0 }), window.setTimeout(() => { this.scrolled = !0, this.rafLoop() }), document.body.classList.add("use-inline-navbar") } rafLoop() { if (!this.scrolled) return; let t = this.getStickyOffset(this.el); if (t === null) { this.el.classList.remove("sticky-before"), this.el.classList.remove("sticky-active"), this.el.classList.remove("sticky-after"); return } this.el.classList.toggle("sticky-before", t >= 1), this.el.classList.toggle("sticky-active", t === 0), this.el.classList.toggle("sticky-after", t <= -1), this.scrolled = !1 } getStickyOffset(t) { let e = window.getComputedStyle(t); if (!e.top) return null; let s = t.getBoundingClientRect(), i = this.pxToNumber(e.top); return Math.floor(s.top - i) } getStickyParent(t) { let e = t.getAttribute("data-sticky-parent"); if (e) { let i = t.closest(e); if (i) return i } let s = t.parentElement; for (; s;) { if (window.getComputedStyle(s).position === "relative") return s; s = s.parentElement } return null } pxToNumber(t) { return parseInt(t.slice(0, t.length - 2)) } }; var te = class extends st { constructor(t) { super(t.querySelector(".TemplateStickyScrollTabs__stickyNav")); this.mobileMenuActive = !1; this.activeSectionId = null; this.parent = t, this.tabButtons = Array.from(this.parent.querySelectorAll(".TemplateStickyScrollTabs__navButton a")), this.tabContentSections = this.tabButtons.map(e => { let s = e.getAttribute("href").slice(1); return document.getElementById(s) }), this.mobileMenuButton = this.el.querySelector(".TemplateStickyScrollTabs__stickyNav__mobileMenuButton"), this.mobileMenuButton && this.mobileMenuButton.addEventListener("click", () => this.toggleMobileMenu()) } rafLoop() { if (!this.scrolled) return; super.rafLoop(); let t = this.getActiveSection(); this.setActiveSection(t) } getActiveSection() { let t = this.getStickyOffset(this.el), e = null; if (t !== null && t <= 0) { e = this.tabContentSections[0].id; for (let s of this.tabContentSections.slice(1)) s.getBoundingClientRect().top <= 60 && (e = s.id) } return e } setActiveSection(t) { if (t === this.activeSectionId) return; let e = null; for (let s of this.tabButtons) { let i = s.parentElement, n = s.getAttribute("href").slice(1); i.classList.toggle("active", n === t), n === t && (e = getComputedStyle(i).getPropertyValue("--primary-color")) } for (let s of this.tabContentSections) s.classList.toggle("active", s.id === t); e ? this.el.style.setProperty("--active-color", e) : this.el.style.removeProperty("--active-color"), this.activeSectionId = t } toggleMobileMenu(t) { typeof t == "undefined" && (t = !this.mobileMenuActive), this.el.classList.toggle("mobile-menu-active", t), this.mobileMenuActive = t, t && window.setTimeout(() => { document.body.addEventListener("click", () => { this.toggleMobileMenu(!1) }, { once: !0 }) }) } }; var ee = class { constructor(t) { this.el = t, this.tabs = Array.from(t.querySelectorAll('a[role="tab"]')); let e = this.getInitialActiveTab(), s = window.location.hash.substring(1); this.tabPanels = this.tabs.map(i => { let n = this.getIdFromAnchorElement(i), o = document.getElementById(n); if (!o) throw new Error(`tabpanel #${n} not found`); return s === n && (e = n), o }), this.setActiveTab(e), this.tabs.forEach(i => { i.addEventListener("click", n => { this.getIdFromAnchorElement(i) && (n.preventDefault(), this.setActiveTab(this.getIdFromAnchorElement(i))) }) }) } getInitialActiveTab() { let t = this.el.getAttribute("data-initial-tab"); if (t) return t; if (this.tabs[0].getAttribute("data-live-date")) { let e = "", s = new Date().toISOString().slice(0, 10); for (let i of this.tabs) { let n = i.getAttribute("data-live-date"); n && n <= s && (e = this.getIdFromAnchorElement(i)) } if (e) return e } return this.getIdFromAnchorElement(this.tabs[0]) } setActiveTab(t) { this.tabs.forEach(e => { this.getIdFromAnchorElement(e) === t ? (this.activeTab = e, e.classList.add("active"), e.setAttribute("aria-selected", "true")) : (e.classList.remove("active"), e.setAttribute("aria-selected", "false")) }), this.tabPanels.forEach(e => { e.id === t ? (this.activeTabPanel = e, e.classList.add("active"), e.setAttribute("aria-hidden", "false")) : (e.classList.remove("active"), e.setAttribute("aria-hidden", "true")) }) } getIdFromAnchorElement(t) { return t.href.split("#")[1] } }; var se = class {
  constructor(t) { this.rpc = new X; this.el = t, this.init() } async init() { let t = this.getLocale(), e = await this.rpc.fetch("events.list", { locale: t }); console.log(e), this.el.classList.add("ready"); let s = e.data?.upcomingEvents || []; if (!s.length) { this.el.classList.add("empty"); return } let i = this.el.querySelector(".upcomingevents__events"); if (i) { let n = s.map(o => this.renderEvent(o)); Q(n, i) } } getLocale() { return (document.documentElement.lang || "en").replace("-", "_") } getLocaleForDate() { let t = this.getLocale(); return t === "zh_Hant" ? "zh-TW" : t === "pt_BR" ? "pt-BR" : t.replace("_", "-") } renderEvent(t) {
    let e = t.image.url || ""; e.startsWith("https://lh3.") && e.indexOf("=") === -1 && (e = e + "=w500"); let s = this.formatEventDay(t), i = t.eventName || t.title, n = t.description || t.title; return i === n && (n = ""), J`
      <a class="upcomingevents__event" href="${t.url}">
        <div class="upcomingevents__event__imageAndDate">
          <div class="upcomingevents__event__image">
            <img src="${e}" width="${t.image.width}" height="${t.image.height}">
          </div>
          <div class="upcomingevents__event__calendar">
            <div class="upcomingevents__event__calendar__day">${this.formatEventDay(t)}</div>
            <div class="upcomingevents__event__calendar__month">${this.formatEventMonth(t)}</div>
          </div>
        </div>
        <div class="upcomingevents__event__content">
          <div class="upcomingevents__event__title">${i}</div>
          <div class="upcomingevents__event__body">${n}</div>
        </div>
      </a>
    `} formatEventMonth(t) { let e = this.getLocaleForDate(), s = this.parseDate(t.startDate), i = this.parseDate(t.endDate), n = s.toLocaleDateString(e, { month: "short" }), o = i.toLocaleDateString(e, { month: "short" }); return n === o ? n : `${n}-${o}` } formatEventDay(t) { let e = this.getLocaleForDate(), s = this.parseDate(t.startDate), i = this.parseDate(t.endDate), n = s.toLocaleDateString(e, { day: "numeric" }), o = i.toLocaleDateString(e, { day: "numeric" }); return n === o ? n : `${n}-${o}` } initDates() { let t = this.el.querySelectorAll(".upcomingevents__content__date"), e = (document.documentElement.lang || "en").replace("_", "-"); for (let s of Array.from(t)) { let i = s.getAttribute("data-date"), n = this.parseDate(i), o = s.querySelector(".upcomingevents__content__date__month"); o && (o.textContent = n.toLocaleDateString(e, { month: "short" })); let a = s.querySelector(".upcomingevents__content__date__day"); a && (a.textContent = n.toLocaleDateString(e, { day: "numeric" })) } } parseDate(t) { let e = t.split("-"); return new Date(+e[0], +e[1] - 1, +e[2]) }
}; var ie = class { constructor() { this.loadedScripts = {}, this.disposed = !1 } load(t, e) { let s = this.loadedScripts[t]; if (s) return s; let i = new Promise((n, o) => { if (e.test()) { n(); return } this.renderScriptTag(t, e); let a = Date.now(), l = e.timeout || 5e3, c = () => { if (this.disposed) { o("script loader is disposed"); return } if (e.test()) { n(); return } if (Date.now() - a > l) { o(`failed to load ${t} due to timeout`); return } window.requestAnimationFrame(c) }; window.requestAnimationFrame(c) }); return this.loadedScripts[t] = i, i.catch(n => { console.error(`failed to load ${t}`), console.error(n), delete this.loadedScripts[t] }), i } renderScriptTag(t, e) { let s = document.createElement("script"); if (e == null ? void 0 : e.attrs) for (let i in e.attrs) { let n = e.attrs[i]; s.setAttribute(i, n) } s.src = t, document.body.appendChild(s) } renderDom(t) { this.renderScriptTag(t) } dispose() { this.loadedScripts = {}, this.disposed = !0 } }; var hs = "https://www.youtube.com/iframe_api?trustedtypes=1", cs = { namespace: "degu-youtube-modal", useHandlerOnMobile: !0, transitionDuration: 300, parentSelector: "body", playerVars: { autohide: 1, autoplay: 1, fs: 1, modestbranding: 1, rel: 0, showinfo: 0, iv_load_policy: 3 }, scriptLoader: new ie }, Lt = { ENTER: "Enter", ESC: "Escape", SPACE: " " }, ne = class { constructor(t) { this.isVisible = !1, this.config = Object.assign({}, cs, t), this.container = document.querySelector(this.config.parentSelector); let e = this.createDom("div", this.config.namespace); e.setAttribute("aria-modal", "true"), e.setAttribute("role", "dialog"); let s = this.createDom("button", `${this.config.namespace}__x`); s.setAttribute("aria-label", "Close video player"), s.setAttribute("tabindex", "0"), s.addEventListener("click", () => { this.setActive(!1) }), this.closeEl = s; let i = this.createDom("div", `${this.config.namespace}__attribution`); this.attributionEl = i; let n = this.createDom("div", `${this.config.namespace}__player`); this.playerEl = n; let o = this.createDom("div", `${this.config.namespace}__mask`); e.appendChild(s), e.appendChild(i), e.appendChild(n), e.appendChild(o), this.modalEl = e, this.container.appendChild(e), document.addEventListener("click", this.handleEvent.bind(this)), document.addEventListener("keydown", this.handleKeyboardEvent.bind(this)) } async play(t, e) { let s = e || {}; if (this.config.useHandlerOnMobile && (rt() || ot())) { let i = `https://m.youtube.com/watch?v=${t}`; s.startTime && (i = `${i}&t=${s.startTime}s`), window.location.href = i; return } if (await this.config.scriptLoader.load(hs, { test: () => window.YT && window.YT.loaded === 1 }), s.attribution && (this.attributionEl.textContent = s.attribution), this.setActive(!0), this.player) { if (t === this.activeVideoId) return; this.player.loadVideoById(t, s.startTime || 0, "large"), this.activeVideoId = t } else { let i = Object.assign({}, this.config.playerVars); s.startTime && (i.start = s.startTime), i.origin = location.protocol + "//" + location.host; let n = { videoId: t, playerVars: i, events: { onReady: o => { o.target.playVideo() } } }; this.player = new YT.Player(this.playerEl, n) } } getPlayOptionsFromAttrs(t) { let e = {}, s = +(t.getAttribute(`data-${this.config.namespace}-video-start-seconds`) || 0); s > 0 && (e.startTime = s); let i = t.getAttribute(`data-${this.config.namespace}-attribution`); return i && (e.attribution = i), e } setActive(t) { t ? (this.lastScrollY = window.pageYOffset, this.lastFocusedEl = document.activeElement, window.setTimeout(() => { this.closeEl.focus(), this.config.onModalOpen && this.config.onModalOpen(this) }, this.config.transitionDuration + 100)) : window.setTimeout(() => { this.lastFocusedEl && (this.lastFocusedEl.focus(), this.lastFocusedEl = void 0), window.scrollTo({ left: 0, top: this.lastScrollY }), this.config.onModalClose && this.config.onModalClose(this) }, this.config.transitionDuration + 100), this.setVisible(t) } dispose() { document.removeEventListener("click", this.handleEvent.bind(this)), document.removeEventListener("keydown", this.handleKeyboardEvent.bind(this)), this.modalEl && this.container.removeChild(this.modalEl) } createDom(t, e, ...s) { let i = document.createElement(t); return i.className = e, s && s.length && s.forEach(n => i.appendChild(n)), i } handleEvent(t) { let e = t.target; for (; e;) { let s = `data-${this.config.namespace}-video-id`, i = e.getAttribute(s); if (i) { t.preventDefault(); let n = this.getPlayOptionsFromAttrs(e); this.play(i, n); return } e = e.parentElement } } handleKeyboardEvent(t) { if (this.isVisible) { if (!this.player) return; t.key === Lt.ESC ? this.setActive(!1) : t.key === Lt.SPACE && (this.player.getPlayerState() === YT.PlayerState.PLAYING ? this.player.pauseVideo() : this.player.playVideo()) } else (t.key === Lt.ENTER || t.key === Lt.SPACE) && this.handleEvent(t) } setVisible(t) { window.setTimeout(() => { this.player && (t ? this.player.getPlayerState() !== YT.PlayerState.PLAYING && this.player.playVideo() : this.player.pauseVideo()) }, 100), window.setTimeout(() => { this.modalEl.classList.toggle(`${this.config.namespace}--enabled`, t) }, t ? 0 : this.config.transitionDuration), window.setTimeout(() => { this.modalEl.classList.toggle(`${this.config.namespace}--visible`, t), this.isVisible = t }, t ? this.config.transitionDuration : 0) } }; var re = class { constructor(t) { this.el = t, this.init() } init() { let t = this.el.querySelector(".TemplateEventTickets__ticketsWrap--MultiTicketWithTabs"); t && new Xe(t); let e = this.el.querySelector(".TemplateEventTickets__ticketsWrap--MultiTicketWithDescriptions"); e && new Ye(e) } }, Xe = class { constructor(t) { this.el = t, this.scrollEl = this.el.querySelector(".TemplateEventTickets__tickets"), this.cards = Array.from(this.el.querySelectorAll(".TemplateEventTickets__ticketContainer")), this.buttons = Array.from(this.el.querySelectorAll(".TemplateEventTickets__ticketsTab")), this.init() } init() { this.buttons.forEach((t, e) => { t.addEventListener("click", () => { this.scrollTo(e) }) }), this.cards.forEach((t, e) => { t.addEventListener("click", () => { this.scrollTo(e) }) }), this.scrollEl.addEventListener("scroll", () => this.onScroll()), this.onScroll() } scrollTo(t) { let e = this.cards[t], s = (this.scrollEl.offsetWidth - e.offsetWidth) / 2, i = e.offsetLeft - s; this.scrollEl.scroll({ left: i, behavior: "smooth" }) } onScroll() { if (!this.scrollEl || this.cards.length === 0) return; let t = this.scrollEl.scrollLeft, e = window.getComputedStyle(this.scrollEl).columnGap, s = window.parseInt(e.slice(0, e.length - 2)), n = this.cards[0].offsetWidth, o = n + s, a = 0; for (let l = this.cards.length - 1; l >= 0; l--) { let c = l * o - .5 * n; if (t > c) { a = l; break } } this.scrollEl.scrollLeft >= this.scrollEl.scrollWidth - this.scrollEl.offsetWidth && (a = this.cards.length - 1), this.setActiveCard(a) } setActiveCard(t) { this.buttons.forEach((e, s) => { e.classList.toggle("active", t === s) }), this.cards.forEach((e, s) => { e.classList.toggle("active", t === s) }) } }, Ye = class { constructor(t) { this.el = t, this.buttons = Array.from(this.el.querySelectorAll(".TemplateEventTickets__ticketsTab")), this.tabContents = Array.from(this.el.querySelectorAll(".TemplateEventTickets__ticketsLayout")), this.init() } init() { this.buttons.forEach(t => { t.addEventListener("click", () => { let e = t.getAttribute("data-tab"); e && this.setActiveTab(e) }) }) } setActiveTab(t) { this.tabContents.forEach(e => { e.classList.toggle("active", t === e.getAttribute("data-tab")) }) } }; function _(r, t, ...e) { let s = document.createElement(r); if (t) for (let i in t) i === "text" ? s.textContent = String(t[i]) : s.setAttribute(i, String(t[i])); return e && e.length > 0 && e.forEach(i => s.appendChild(i)), s } var oe = class {
  constructor(t) { this.el = t, this.locale = document.documentElement.lang || "en", this.strings = {}, this.init() } init() { this.fetchPosts().then(() => { this.el.closest(".TemplateRecentNewsCards").classList.remove("loading") }), this.strings.learn_more = this.el.getAttribute("data-learn-more") || "Learn more" } async fetchPosts() { let t = this.el.getAttribute("data-tag") || null, e = await window.fetch("/post/api/blog.list", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ locale: this.locale, tag: t }) }); if (!e.ok) return; let i = (await e.json()).data.blogPosts; this.renderPosts(i) } renderPosts(t) { t.forEach(e => { let s = _("div", { class: "TemplateRecentNewsCards__card", href: e.url }, this.createImage(e), this.createContent(e)); this.el.appendChild(s) }) } createImage(t) { let e = _("div", { class: "TemplateRecentNewsCards__card__image" }), s = t.fields?.meta || {}; if (s.image?.url) { let i = s.image, n = i.url; if (fe(n)) { let a = window.devicePixelRatio > 1 ? 2400 : 1200; n = `${n}=s${a}-rj` } let o = _("img", { src: n, width: i.width, height: i.height, alt: i.alt || "" }); e.appendChild(o) } return e } createContent(t) {
    let e = _("div", { class: "TemplateRecentNewsCards__card__content" }), s = t.fields?.meta || {}; if (s.title) { let i = _("div", { class: "TemplateRecentNewsCards__card__content__title", text: s.title }); e.appendChild(i) } if (t.url) {
      let i = _("div", { class: "TemplateRecentNewsCards__card__content__button__label", text: this.strings.learn_more }), n = _("div", { class: "TemplateRecentNewsCards__card__content__button__icon" }); n.innerHTML = `
<svg width="16" height="14" viewBox="0 0 16 14" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M15.2075 7.39918C15.2075 7.13195 15.1037 6.87323 14.9201 6.68355L9.67642 1.01889C9.46888 0.803337 9.25339 0.708496 9.02995 0.708496C8.51913 0.708496 8.15197 1.09651 8.15197 1.62245C8.15197 1.89833 8.25571 2.13111 8.41539 2.30357L10.2111 4.26943L12.5257 6.55426L10.6741 6.43354H1.00076C0.466018 6.43354 0.098877 6.83014 0.098877 7.39918C0.098877 7.95965 0.466018 8.35624 1.00076 8.35624H10.6741L12.5257 8.23553L10.2111 10.5204L8.41539 12.4862C8.25571 12.6587 8.15197 12.8915 8.15197 13.1674C8.15197 13.6933 8.51913 14.0813 9.02995 14.0813C9.25339 14.0813 9.46888 13.9864 9.66047 13.7882L14.9201 8.10623C15.1037 7.91655 15.2075 7.6579 15.2075 7.39918Z" fill="currentColor"/>
</svg>`.trimStart(); let o = _("a", { class: "TemplateRecentNewsCards__card__content__button", href: t.url }, i, n), a = _("div", { class: "TemplateRecentNewsCards__card__content__buttons" }, o); e.appendChild(a)
    } return e
  }
}; var ae = class { constructor(t) { this.el = t; let e = this.el.querySelector(".open-button"); e && e.addEventListener("click", () => this.open()); let s = this.el.querySelector(".close-button"); s && s.addEventListener("click", () => this.close()), window.addEventListener("click", i => { i.target && this.el.contains(i.target) || this.close() }) } open() { this.el.classList.add("opened") } close() { this.el.classList.remove("opened") } }; var le = class { constructor(t) { this.imageSources = t, this.blobs = {}, this.images64 = {}, this.maxRetries = 3 } load() { return new Promise(t => { this.imageSources || t(this.blobs); let e = this.imageSources.map(s => this.loadBlob(s)); Promise.all(e).then(() => { t(this.blobs) }) }) } loadBlob(t, e = 0) { return new Promise(s => { fetch(t).then(i => { if (i.ok) return i.blob(); if (e++, e >= this.maxRetries) throw new Error(`failed after ${e} tries`); return this.loadBlob(t, e) }).then(i => { this.blobs && i && (this.blobs[t] = i), s(i) }) }) } loadBase64Images() { return new Promise(t => { let e = this.imageSources.map(s => this.loadBlobAsBase64Image(s)); Promise.all(e).then(() => { t(this.images64) }) }) } loadBlobAsBase64Image(t, e = 0) { return new Promise((s, i) => { fetch(t).then(n => n.ok ? n.blob() : (e++, e >= this.maxRetries && i(`failed after ${e} tries`), this.loadBlobAsBase64Image(t, e))).then(n => { n && De(n).then(o => { this.images64[t] = o, s(n) }) }) }) } dispose() { this.imageSources = [], this.images64 = {}, this.blobs = {} } }; function Ze(r, t, e, s) { return { r: f(r.r, t.r, e, s) >> 0, g: f(r.g, t.g, e, s) >> 0, b: f(r.b, t.b, e, s) >> 0, a: f(r.a, t.a, e, s) } } function Ke(r) { let t = r.r, e = r.g, s = r.b; return "#" + ((1 << 24) + (t << 16) + (e << 8) + s).toString(16).slice(1).toUpperCase() } function ds(r, t = 1) { let e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; r = r.replace(e, (n, o, a, l) => o + o + a + a + l + l); let s = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(r), i = null; return s && (i = { r: parseInt(s[1], 16), g: parseInt(s[2], 16), b: parseInt(s[3], 16), a: t }), i } function _t(r) { if (at(r)) return ds(r); if (ht(r) && (r = r.replace(")", ",1)"), r = r.replace("rgb", "rgba")), lt(r)) { let t = r.match(/^rgba\(\s*?(\d{1,3})\s*?,\s*?(\d{1,3})\s*?,\s*?(\d{1,3})\s*?,\s*?(\d*(?:\.\d+)?)\)$/); return t ? { r: +t[1], g: +t[2], b: +t[3], a: +t[4] } : null } return null } function Qe(r) { return `rgba(${r.r}, ${r.g}, ${r.b}, ${r.a})` } var b; (function (r) { r.number = "num", r.unit = "unit", r.cssHex = "cssHex", r.rgba = "rgba", r.rgb = "rgb" })(b || (b = {})); function ms(r) { let t = r.replace(/[a-zA-Z%]+/g, ""), e = r.match(/[a-zA-Z%]+/g), s = { value: null, unit: null, type: null, valueType: null, originalValue: r }; return lt(r) ? (s.type = b.rgba, s.value = _t(r), s.valueType = b.rgba) : ht(r) ? (s.type = b.rgb, s.value = _t(r), s.valueType = b.rgba) : at(r) ? (s.value = _t(r), s.type = b.cssHex, s.valueType = b.rgba) : (s.value = t ? +t : null, s.unit = e ? e[0] : null, s.type = b.unit, s.valueType = b.number), s.originalValue = r, s } var he = { parse: ms }; var it = class { constructor(t) { this.interpolateConfig = t, this.currentValue = 0, this.currentProgress = 0, this.calculate(0) } modify(t) { return new it(t) } calculate(t) { if (this.currentProgress = t, E(this.interpolateConfig.from)) this.currentValue = f(this.interpolateConfig.from, this.interpolateConfig.to, this.currentProgress, this.interpolateConfig.easeFunction); else { let e = he.parse(this.interpolateConfig.from), s = he.parse(this.interpolateConfig.to); if (e.valueType === b.number && (this.currentValue = f(e.value, s.value, this.currentProgress, this.interpolateConfig.easeFunction), this.currentValue = `${this.currentValue}${e.unit}`), e.valueType === b.rgba) { let i = Ze(e.value, s.value, this.currentProgress, this.interpolateConfig.easeFunction); this.currentValue = Qe(i) } } return this.currentValue } }; var Ct = { errors: { FROM_TO_EQUAL: "Range progress from and to values should not equal each other.", FROM_GREATER: "Range progress from greater than the value of to" }, checkInvalidRangedProgresses: r => { r.forEach(t => { if (t.from === t.to) throw console.error(t), new Error(Ct.errors.FROM_TO_EQUAL); if (t.from > t.to) throw console.error(t), new Error(Ct.errors.FROM_GREATER) }) }, findBestMatchingRangedProgress(r, t) { let e = t[0]; return t.forEach(s => { let i = e; e.to <= r && (e = s), e.from > r && (e = i) }), e } }, At = class { constructor(t) { this.parentProgress = 0, this.currentValues = {}, this.config = t, this.updateConfig(this.config) } updateConfig(t) { if (this.config = this.createStaggers(t), !this.config.interpolations) throw new Error("Multiinterpolation config is missing interpolations"); this.config.interpolations = this.config.interpolations.map(e => (Ct.checkInvalidRangedProgresses(e.progress), e)) } createStaggers(t) { let e = []; return [...t.interpolations].forEach(s => { if (s.stagger && !s.staggerItem) for (let i = 0; i < s.stagger.count; i++) { let n = Object.assign({}, s); n.progress = n.progress.map(o => (o = Object.assign({}, o), o.to += i * s.stagger.progressOffset, o.from += i * s.stagger.progressOffset, n.id = s.id + "-" + i, n.staggerItem = !0, o)), e.push(n) } }), e.forEach(s => { t.interpolations.push(s) }), t } getCalculations() { return this.currentValues } calculate(t) { return this.parentProgress = t, this.config.interpolations.forEach(e => { let s = Ct.findBestMatchingRangedProgress(this.parentProgress, e.progress), i = Te(this.parentProgress, s.from, s.to); if (e.noInterpolation) { if (!e.noInterpolationDefault) throw new Error("You are using noInterpolation without a noInterpolation default"); xe(this.parentProgress, s.from, s.to, !0) ? this.currentValues[e.id] = s.end : this.currentValues[e.id] = e.noInterpolationDefault } else { let n = new it({ from: s.start, to: s.end, easeFunction: s.easingFunction || j }).calculate(i); this.currentValues[e.id] = n, e.visibilityId && (this.currentValues[e.visibilityId] = n <= 0 ? "hidden" : "visible") } e.onUpdate && e.onUpdate(e.id, this.parentProgress, this.currentValues[e.id]) }), this.currentValues } }; var ce = class { constructor(t) { this.rafLoop = t, this.raf = new v(() => { this.animationLoop_() }), this.duration = 0, this.progress = 0, this.timeElapsed = 0, this.timeSnapshot = 0, this.playing = !1, this.completeCallback = null } animationLoop_() { if (!this.playing) return; let t = Ie(this.timeSnapshot, k()); this.timeElapsed += t, this.progress = we(this.timeElapsed / this.duration), this.timeSnapshot = k(), this.progress < 1 ? this.rafLoop && this.rafLoop(this.progress) : (this.rafLoop && this.rafLoop(1), this.reset(), this.raf.stop(), this.completeCallback && this.completeCallback(1)) } setDuration(t) { this.duration = t } setFps(t) { this.raf.setFps(t) } onComplete(t) { this.completeCallback = t } play() { this.playing || (this.playing = !0, this.timeSnapshot = k(), this.raf.start()) } reset() { this.playing = !1, this.raf.stop(), this.timeElapsed = 0 } pause() { this.raf.stop(), this.playing = !1 } dispose() { this.raf.dispose() } }; var de = class { constructor(t) { this.lastUpdateTime = 0, this.scheduleTimeout = 0, this.fps = t, this.locked = !0 } setFps(t) { this.fps = t } lock(t) { this.locked = t } schedule(t) { this.cancelSchedule(), this.scheduleTimeout = window.setTimeout(() => { this.locked = !1, t(), this.locked = !0 }, 1e3 / this.fps + 1) } cancelSchedule() { this.scheduleTimeout && window.clearTimeout(this.scheduleTimeout) } canRun() { if (this.cancelSchedule(), !this.locked) return !0; if (this.lastUpdateTime) { let e = k() - this.lastUpdateTime, s = this.fps === 0 ? 0 : 1e3 / this.fps; return e > s ? (this.lastUpdateTime = k(), !0) : !1 } return this.lastUpdateTime ? !1 : (this.lastUpdateTime = k(), !0) } }; var O = class { constructor() { } static setFillColor(t, e) { t.fillStyle = e } static setStrokeColor(t, e) { t.strokeStyle = e } static line(t, e, s, i, n) { t.beginPath(), t.moveTo(e, s), t.lineTo(i, n), t.stroke() } static quickText(t, e, s, i) { t.font = "12px sans-serif", t.strokeText(e, s, i) } static point(t, e, s, i = 5) { t.fillRect(e, s, i, i) } static vectorLine(t, e, s) { O.line(t, e.x, e.y, s.x, s.y) } static vectorPoint(t, e, s = 5) { O.point(t, e.x, e.y, s) } static vectorQuadrilateral(t, e, s, i, n) { t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(s.x, s.y), t.lineTo(i.x, i.y), t.lineTo(n.x, n.y), t.closePath(), t.fill() } static drawVectors(t, e) { t.beginPath(), t.moveTo(e[0].x, e[0].y), e.forEach(s => { t.lineTo(s.x, s.y) }), t.closePath(), t.fill() } static getColorAtPointAsRgb(t, e) { let s = t.getImageData(e.x, e.y, 1, 1).data; return { r: s[0], g: s[1], b: s[2] } } static getColorAtPointAsHex(t, e) { let s = O.getColorAtPointAsRgb(t, e); return Ke(s) } }; var me = { NO_ELEMENT: "An element is required for canvas image sequence", NO_IMAGE_SETS: "Image sets are required for canvas image sequence", NO_IMAGES: "There are no images defined in your canvas image sequence image set" }, ue = class { constructor(t, e, s, i) { if (this.lerpAmount = 1, this.element = t, !t) throw new Error(me.NO_ELEMENT); if (!e) throw new Error(me.NO_IMAGE_SETS); this.imageSets = e, this.activeImageSet = null, this.blobCache = {}, this.options = s, this.isPlaying = !1, this.canvasElement = document.createElement("canvas"), this.options && this.options.ariaLabel ? (this.canvasElement.setAttribute("aria-label", this.options.ariaLabel), this.canvasElement.setAttribute("role", "img")) : this.canvasElement.setAttribute("aria-hidden", "true"), this.context = this.canvasElement.getContext("2d"), this.dpr = Pe(i, window.devicePixelRatio || 1), this.canvasWidth = 0, this.canvasHeight = 0, this.imageNaturalHeight = 0, this.imageNaturalWidth = 0, this.currentFrame = 0, this.lastDrawSource = null, this.targetFrame = 0, this.containScale = null, this.disposed = !1, this.fps = new de(ye() ? 30 : 60), this.cacheImage = new Image, this.rafTimer = null, this.multiInterpolate = null, this.clipMultiInterpolate = null, this.clipPathType = null, this.blobLoader = null, this.progress = null, this.playDefer = null, this.domWatcher = new w, this.domWatcher.add({ element: window, on: "smartResize", callback: () => { this.resize(), this.flush(), this.lastDrawSource = null, this.fps.lock(!1), this.lastRenderSource && this.draw(this.lastRenderSource), this.fps.lock(!0) }, id: "resize", eventOptions: { passive: !0 } }), this.resize(), this.domWatcher.run("resize"), this.domWatcher.add({ element: window, on: "smartResize", callback: () => { this.getSourceThatShouldLoad(this.imageSets) !== this.activeImageSet && (this.loadNewSet(this.imageSets), this.load().then(() => { this.lastDrawSource = null, this.fps.lock(!1), this.renderByProgress(this.progress || 0), this.fps.lock(!0) })) }, id: "image-set-resize", eventOptions: { passive: !0 } }), this.element.appendChild(this.canvasElement), this.readyPromise = new nt, this.loadNewSet(e), this.lastRenderSource = null, this.lastDrawSource = null, this.draw = ke(this.draw.bind(this)) } setMultiInterpolation(t) { this.multiInterpolate = new At({ interpolations: [{ id: "sequence", progress: t }] }) } resize() { this.canvasWidth = this.element.offsetWidth, this.canvasHeight = this.element.offsetHeight, this.canvasElement.width = this.element.offsetWidth * this.dpr, this.canvasElement.height = this.element.offsetHeight * this.dpr, this.canvasElement.style.width = this.canvasWidth + "px", this.canvasElement.style.height = this.canvasHeight + "px", this.context.scale(this.dpr, this.dpr) } load() { return !this.blobLoader || !this.activeImageSet ? (window.setTimeout(() => { this.readyPromise.resolve() }), this.readyPromise.getPromise()) : ((() => { this.blobLoader.load().then(e => { this.blobCache = e, this.setImageDimensions().then(() => { this.blobLoader.dispose(), this.readyPromise.resolve(e) }) }) })(), this.readyPromise.getPromise()) } loadNewSet(t) { if (this.blobLoader && this.blobLoader.dispose(), this.imageSets = t, this.activeImageSet = this.getSourceThatShouldLoad(this.imageSets), this.activeImageSet && !be(this.activeImageSet.images)) throw new Error(me.NO_IMAGES); this.activeImageSet ? this.blobLoader = new le(this.activeImageSet.images) : this.blobLoader = null, this.blobCache = {}, this.flush(), this.lastRenderSource = null, this.readyPromise = new nt } getSourceThatShouldLoad(t) { let e = []; return t.forEach(s => { s.when ? s.when() && e.push(s) : e.push(s) }), e[0] } makeImage(t) { return new Promise(e => { if (!t || !this.blobCache[t]) { e(null); return } URL.revokeObjectURL(this.cacheImage.src), this.cacheImage.onload = () => { e(this.cacheImage) }, this.cacheImage.src = URL.createObjectURL(this.blobCache[t]) }) } setImageDimensions() { return new Promise(t => { let e = this.activeImageSet.images[0], s = this.blobCache[e]; He(s).then(i => { let n = !i.naturalWidth; this.imageNaturalHeight = n ? i.height : i.naturalHeight, this.imageNaturalWidth = n ? i.width : i.naturalWidth, G(i), i = null, t() }) }) } getActiveImages() { return this.activeImageSet.images } setClipInterpolations(t) { this.clipPathType = t.type, this.clipMultiInterpolate = new At({ interpolations: t.interpolations }) } renderByProgress(t, e = !1) { this.progress = dt(t), !this.isPlaying && this.renderProgress(t, e) } renderProgress(t, e = !1) { let s = dt(t); if (this.multiInterpolate && !e) { let i = this.multiInterpolate.calculate(s); s = dt(i.sequence) } if (this.clipMultiInterpolate && this.clipMultiInterpolate.calculate(s), (s >= .95 || s <= .05) && this.flush(), this.activeImageSet) { let i = this.activeImageSet.images.length - 1, n = Math.ceil(x(0, i, s)); this.renderFrame(n) } } renderFrame(t) { if (!this.readyPromise.complete) return; this.targetFrame = t; let e = Math.abs(this.targetFrame - this.currentFrame); e > 1 && !this.isPlaying && this.lerpAmount < 1 ? (this.currentFrame = x(this.currentFrame, this.targetFrame, this.lerpAmount), e = Math.abs(this.targetFrame - this.currentFrame), e >= .001 && window.requestAnimationFrame(() => { this.renderFrame(this.targetFrame) })) : this.currentFrame = this.targetFrame; let s = this.activeImageSet.images[Math.round(this.currentFrame)]; this.draw(s) } flush() { this.draw(""), this.draw(null) } drawRectangle(t) { let e = { tl: t.radius, tr: t.radius, br: t.radius, bl: t.radius }; this.context.beginPath(), this.context.moveTo(t.left + e.tl, t.top), this.context.lineTo(t.right - e.tr, t.top), this.context.quadraticCurveTo(t.right, t.top, t.right, t.top + e.tr), this.context.lineTo(t.right, t.bottom - e.br), this.context.quadraticCurveTo(t.right, t.bottom, t.right - e.br, t.bottom), this.context.lineTo(t.left + e.bl, t.bottom), this.context.quadraticCurveTo(t.left, t.bottom, t.left, t.bottom - e.bl), this.context.lineTo(t.left, t.top + e.tl), this.context.quadraticCurveTo(t.left, t.top, t.left + e.tl, t.top), this.context.closePath(), this.context.fill() } applyCanvasClipping() { if (this.clipPathType === "inset") { let t = this.clipMultiInterpolate.getCalculations() || {}, e = t.top || 0, s = t.bottom || 0, i = t.left || 0, n = t.right || 0, o = t["border-radius"] || 0; this.drawRectangle({ top: this.canvasHeight - (1 - e) * this.canvasHeight, left: this.canvasWidth - (1 - i) * this.canvasWidth, right: (1 - n) * this.canvasWidth, bottom: (1 - s) * this.canvasHeight, radius: o }), this.context.clip() } } clear() { this.context.clearRect(0, 0, this.canvasWidth, this.canvasHeight) } async draw(t) { if (!t || this.disposed || t === this.lastDrawSource) return; if (this.lastDrawSource = t, !this.fps.canRun()) { this.fps.schedule(() => { this.lastDrawSource = null, this.draw(t) }); return } let e = await this.makeImage(t); if (!e) return; let s = { width: this.imageNaturalWidth, height: this.imageNaturalHeight }, i = { width: this.canvasWidth, height: this.canvasHeight }; if (this.clear(), It(this.clipPathType) || (this.context.save(), this.applyCanvasClipping()), this.options && this.options.cover) { let n = _e(i, s); this.options && E(this.options.left) && (n.xOffset = (i.width - s.width * n.scalar) * -this.options.left), this.options && E(this.options.right) && (n.xOffset = -(i.width - s.width * n.scalar), n.xOffset += (i.width - s.width * n.scalar) * this.options.right), this.options && E(this.options.bottom) && (n.yOffset = -(i.height - s.height * n.scalar), n.yOffset += (i.height - s.height * n.scalar) * this.options.bottom), this.options && E(this.options.top) && (n.yOffset = (i.height - s.height * n.scalar) * -this.options.top), this.context.drawImage(e, -n.xOffset >> 0, -n.yOffset >> 0, s.width * n.scalar >> 0, s.height * n.scalar >> 0) } else { this.containScale = Ce(i, s); let n = (i.width - s.width * this.containScale) / 2, o = (i.height - s.height * this.containScale) / 2; this.options && E(this.options.bottom) && (o = i.height - s.height * this.containScale, this.options.bottomNoClip ? o -= (i.height - s.height * this.containScale) * this.options.bottom : o -= i.height * this.options.bottom), this.options && E(this.options.right) && (n = i.width - s.width * this.containScale, this.options.rightNoClip ? n -= (i.width - s.width * this.containScale) * this.options.right : n -= i.width * this.options.right), this.options && E(this.options.top) && (o = 0, this.options.topNoClip ? o = (i.height - s.height * this.containScale) * this.options.top : o += this.options.top * i.height), this.options && E(this.options.left) && (n = 0, this.options.leftNoClip ? n = (i.width - s.width * this.containScale) * this.options.left : n += this.options.left * i.width), this.context.drawImage(e, n >> 0, o >> 0, s.width * this.containScale >> 0, s.height * this.containScale >> 0) } It(this.clipPathType) || this.context.restore(), this.lastRenderSource = t } setSizingOptions(t) { this.options = t } play(t, e, s) { return this.stop(), this.rafTimer = new ce(i => { let n = Le(i, 0, 1, t, e); this.renderProgress(n) }), this.rafTimer.setDuration(s), this.playDefer = new nt, this.rafTimer.onComplete(() => { this.isPlaying = !1, this.playDefer.resolve(), this.rafTimer.dispose() }), this.rafTimer.play(), this.isPlaying = !0, this.playDefer.getPromise() } getHexColorAtPoint(t) { return O.getColorAtPointAsHex(this.context, t) } stop() { this.rafTimer && this.rafTimer.pause(), this.rafTimer && this.rafTimer.dispose(), this.playDefer && this.playDefer.resolve() } getImageSize() { return { width: this.imageNaturalWidth, height: this.imageNaturalHeight } } dispose() { this.disposed = !0, this.stop(), this.domWatcher.dispose(), this.rafTimer && this.rafTimer.dispose(), this.blobLoader && this.blobLoader.dispose(), this.element = null, this.blobCache = null, this.canvasElement = null, G(this.cacheImage), this.cacheImage = null } }; var us = 84, ps = "https://storage.googleapis.com/pgoblog/seasons-light/cosmog-animation/cosmog_{frame}.png", pe = class { constructor(t) { this.el = t, this.images = []; for (let e = 0; e < us; e++)this.images.push(ps.replace("{frame}", String(e).padStart(3, "0"))); this.imageSequence = new ue(this.el, [{ images: this.images }]), this.init() } async init() { this.setPosterImage(), window.matchMedia("(prefers-reduced-motion: no-preference)").matches && (await this.imageSequence.load(), this.removePosterImage(), this.play()) } setPosterImage() { let t = this.images[30]; this.el.setAttribute("style", `background-image: url(${t})`), this.el.classList.add("poster") } removePosterImage() { this.el.removeAttribute("style"), this.el.classList.remove("poster") } play() { this.imageSequence.play(0, 1, 2800).then(() => { this.play() }) } }; function fs() { ot() && document.body.classList.add("android"), rt() && document.body.classList.add("ios") } function gs() { let r = new ge; r.register("CardCarousel", Rt), r.register("CharacterCarousel", Ht), r.register("CosmogAnimation", pe), r.register("EventTickets", re), r.register("FeaturedEvents", Dt), r.register("Gallery", Nt), r.register("LatestNews", Ot), r.register("Navbar", Yt), r.register("MultilineEllipsis", zt, { maxLines: 2 }), r.register("RecentNewsCards", oe), r.register("RocketCarousel", Qt), r.register("SeasonOfLightPopout", ae), r.register("ScrollXState", Jt), r.register("StickyScrollTabs", te), r.register("StickyState", st), r.register("TabList", ee), r.register("UpcomingEvents", se), r.start(), fs(), new URLSearchParams(window.location.search).get("grid") === "true" && Je(), document.addEventListener("keydown", e => { e.ctrlKey && e.key === "g" && bs() }), window.youtubeModal || (window.youtubeModal = new ne({ namespace: "youtube-modal", useHandlerOnMobile: !1 })), setTimeout(() => { document.documentElement.style.scrollBehavior = "smooth" }, 1e3), vs(), Ts() } function bs() { let r = document.querySelector(".grid-overlay"); r ? ys(r) : Je() } function Je() { let r = document.createElement("div"); r.classList.add("grid-overlay"); let t = document.createElement("div"); t.classList.add("grid"); for (let e = 0; e < 12; e++) { let s = document.createElement("div"); s.classList.add("grid__col"), s.textContent = String(e + 1), t.appendChild(s) } r.appendChild(t), document.body.appendChild(r), document.body.setAttribute("grid-overlay", "true") } function ys(r) { r.parentNode.removeChild(r), document.body.removeAttribute("grid-overlay") } function vs() { let r = (document.documentElement.lang || "en").replace("_", "-"); Array.from(document.querySelectorAll("a[href]")).forEach(e => { let s = e.href; if (s && s.startsWith("https://niantic.helpshift.com/")) { let i = new URL(s); i.searchParams.set("l", r), e.href = i.toString() } }) } function Es() { try { return window.self !== window.top } catch (r) { return !0 } } function Ts() { if (Es()) { let r = "_scrolly", t = sessionStorage.getItem(r); if (t) { let e = document.documentElement; e.style.scrollBehavior = "auto", window.scrollTo({ top: window.parseInt(t) }), setTimeout(() => { e.style.removeProperty("scroll-behavior") }) } window.addEventListener("beforeunload", () => { sessionStorage.setItem(r, String(window.scrollY)) }) } } gs(); export { gs as main };
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */